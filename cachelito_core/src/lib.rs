//! # Cachelito Core
//!
//! Core traits and utilities for the Cachelito caching library.
//!
//! This module provides the fundamental building blocks for cache key generation
//! and thread-local cache management.

use std::cmp::PartialEq;
use std::collections::VecDeque;
use std::{cell::RefCell, collections::HashMap, fmt::Debug, thread::LocalKey};

/// Trait defining how to generate a cache key for a given type.
///
/// This trait must be implemented for any type that will be used as a function
/// parameter in a cached function. The cache key is used to uniquely identify
/// cached results.
///
/// # Examples
///
/// ```
/// use cachelito_core::CacheableKey;
///
/// #[derive(Debug)]
/// struct UserId(u64);
///
/// impl CacheableKey for UserId {
///     fn to_cache_key(&self) -> String {
///         format!("user_{}", self.0)
///     }
/// }
/// ```
pub trait CacheableKey {
    /// Converts this value into a string that can be used as a cache key.
    ///
    /// The returned string should uniquely identify the value to ensure
    /// correct cache behavior.
    fn to_cache_key(&self) -> String;
}

/// Marker trait for types that want to use the *default* cache key behavior.
///
/// Implement this trait for any type that should automatically get a cache key
/// derived from its `Debug` representation. This is the simplest way to make
/// a type cacheable.
///
/// # Examples
///
/// ```
/// use cachelito_core::DefaultCacheableKey;
///
/// #[derive(Debug, Clone)]
/// struct Product {
///     id: u32,
///     name: String,
/// }
///
/// // Enable default cache key generation based on Debug
/// impl DefaultCacheableKey for Product {}
/// ```
///
/// # Note
///
/// Types implementing this trait must also implement `Debug`, as the default
/// cache key is generated using `format!("{:?}", value)`.
pub trait DefaultCacheableKey: Debug {}

/// Blanket implementation for any type that explicitly opts in via `DefaultCacheableKey`.
///
/// This automatically implements `CacheableKey::to_cache_key()` for any type that
/// implements `DefaultCacheableKey`, using the type's `Debug` representation as the key.
///
/// # Performance Note
///
/// The cache key is generated by formatting the value with `{:?}`. For complex types,
/// consider implementing `CacheableKey` directly for better performance.
impl<T> CacheableKey for T
where
    T: DefaultCacheableKey + ?Sized,
{
    fn to_cache_key(&self) -> String {
        format!("{:?}", self)
    }
}

// ============================================================================
// Standard Library Type Implementations
// ============================================================================
// These implementations allow all common Rust types to be used as cache keys
// without requiring manual implementation.

// Unsigned integer types
impl DefaultCacheableKey for u8 {}
impl DefaultCacheableKey for u16 {}
impl DefaultCacheableKey for u32 {}
impl DefaultCacheableKey for u64 {}
impl DefaultCacheableKey for u128 {}
impl DefaultCacheableKey for usize {}

// Signed integer types
impl DefaultCacheableKey for i8 {}
impl DefaultCacheableKey for i16 {}
impl DefaultCacheableKey for i32 {}
impl DefaultCacheableKey for i64 {}
impl DefaultCacheableKey for i128 {}
impl DefaultCacheableKey for isize {}

// Floating point types
impl DefaultCacheableKey for f32 {}
impl DefaultCacheableKey for f64 {}

// Boolean type
impl DefaultCacheableKey for bool {}

// Character type
impl DefaultCacheableKey for char {}

// String types
impl DefaultCacheableKey for String {}
impl DefaultCacheableKey for &str {}

// Tuple types (up to 5 elements)
impl<T1: DefaultCacheableKey> DefaultCacheableKey for (T1,) {}
impl<T1: DefaultCacheableKey, T2: DefaultCacheableKey> DefaultCacheableKey for (T1, T2) {}
impl<T1: DefaultCacheableKey, T2: DefaultCacheableKey, T3: DefaultCacheableKey> DefaultCacheableKey
    for (T1, T2, T3)
{
}
impl<
        T1: DefaultCacheableKey,
        T2: DefaultCacheableKey,
        T3: DefaultCacheableKey,
        T4: DefaultCacheableKey,
    > DefaultCacheableKey for (T1, T2, T3, T4)
{
}
impl<
        T1: DefaultCacheableKey,
        T2: DefaultCacheableKey,
        T3: DefaultCacheableKey,
        T4: DefaultCacheableKey,
        T5: DefaultCacheableKey,
    > DefaultCacheableKey for (T1, T2, T3, T4, T5)
{
}

// Option and Result wrapper types
impl<T: DefaultCacheableKey> DefaultCacheableKey for Option<T> {}
impl<T: DefaultCacheableKey, E: DefaultCacheableKey> DefaultCacheableKey for Result<T, E> {}

// Collection types
impl<T: DefaultCacheableKey> DefaultCacheableKey for Vec<T> {}
impl<T: DefaultCacheableKey> DefaultCacheableKey for &[T] {}

/// Represents the policy used for evicting elements in a cache or similar data structure.
///
/// # Variants
///
/// * `FIFO` - First In, First Out eviction policy. Elements are evicted in the order
///   they were added, with the oldest element being removed first.
/// * `LRU` - Least Recently Used eviction policy. Elements are evicted based on
///   usage, where the least recently accessed element is removed first.
///
/// # Derives
///
/// This enum derives the following traits:
///
/// * `Clone` - Enables the creation of a duplicate `EvictionPolicy` value.
/// * `Copy` - Allows `EvictionPolicy` values to be duplicated by simple assignment
///   without consuming the original value.
/// * `Debug` - Provides a human-readable string representation of the `EvictionPolicy`
///   variants for debugging purposes.
#[derive(Clone, Copy, Debug)]
pub enum EvictionPolicy {
    FIFO,
    LRU,
}
/// Returns the default eviction policy (FIFO).
impl EvictionPolicy {
    /// Returns the default eviction policy (FIFO).
    pub const fn default() -> Self {
        EvictionPolicy::FIFO
    }
}

/// Converts a string slice to an `EvictionPolicy`.
/// The conversion is case-insensitive.
/// If the string does not match "lru", it defaults to `FIFO`.
impl From<&str> for EvictionPolicy {
    fn from(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "lru" => EvictionPolicy::LRU,
            _ => EvictionPolicy::FIFO,
        }
    }
}

/// PartialEq implementation for `EvictionPolicy`.
impl PartialEq for EvictionPolicy {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (EvictionPolicy::FIFO, EvictionPolicy::FIFO) => true,
            (EvictionPolicy::LRU, EvictionPolicy::LRU) => true,
            _ => false,
        }
    }
}

/// Core cache abstraction that stores values in a thread-local HashMap.
///
/// This cache is designed to work with static thread-local maps declared using
/// the `thread_local!` macro. Each thread maintains its own independent cache,
/// ensuring thread safety without the need for locks.
///
/// # Type Parameters
///
/// * `R` - The type of values stored in the cache. Must be `'static` to satisfy
///   thread-local storage requirements.
///
/// # Thread Safety
///
/// The cache is thread-safe by design - each thread has its own independent copy
/// of the cache data. This means:
/// - No locks or synchronization needed
/// - No contention between threads
/// - Cache entries are not shared across threads
///
/// # Examples
///
/// ```
/// use std::cell::RefCell;
/// use std::collections::HashMap;
/// use cachelito_core::ThreadLocalCache;
///
/// thread_local! {
///     static MY_CACHE: RefCell<HashMap<String, i32>> = RefCell::new(HashMap::new());
/// }
///
/// let cache = ThreadLocalCache::new(&MY_CACHE);
/// cache.insert("answer", 42);
/// assert_eq!(cache.get("answer"), Some(42));
/// ```
pub struct ThreadLocalCache<R: 'static> {
    /// Reference to the thread-local storage key for the cache HashMap
    pub cache: &'static LocalKey<RefCell<HashMap<String, R>>>,
    /// Reference to the thread-local storage key for the cache order queue
    pub order: &'static LocalKey<RefCell<VecDeque<String>>>,
    /// Maximum number of items to store in the cache
    pub limit: Option<usize>,
    /// Eviction policy to use for the cache
    pub policy: EvictionPolicy,
}

impl<R: Clone + 'static> ThreadLocalCache<R> {
    /// Creates a new `ThreadLocalCache` wrapper around a thread-local storage key.
    ///
    /// # Arguments
    ///
    /// * `cache` - A static reference to a `LocalKey` that stores the cache HashMap
    ///
    /// # Examples
    ///
    /// ```
    /// use std::cell::RefCell;
    /// use std::collections::HashMap;
    /// use cachelito_core::ThreadLocalCache;
    ///
    /// thread_local! {
    ///     static CACHE: RefCell<HashMap<String, String>> = RefCell::new(HashMap::new());
    /// }
    ///
    /// let cache = ThreadLocalCache::new(&CACHE);
    /// ```
    pub const fn new(
        cache: &'static LocalKey<RefCell<HashMap<String, R>>>,
        order: &'static LocalKey<RefCell<VecDeque<String>>>,
        limit: Option<usize>,
        policy: EvictionPolicy,
    ) -> Self {
        Self {
            cache,
            order,
            limit,
            policy,
        }
    }

    /// Retrieves a value from the cache by key.
    ///
    /// # Arguments
    ///
    /// * `key` - The cache key to look up
    ///
    /// # Returns
    ///
    /// * `Some(value)` if the key exists in the cache
    /// * `None` if the key is not found
    ///
    /// # Examples
    ///
    /// ```
    /// # use std::cell::RefCell;
    /// # use std::collections::HashMap;
    /// # use cachelito_core::ThreadLocalCache;
    /// # thread_local! {
    /// #     static CACHE: RefCell<HashMap<String, i32>> = RefCell::new(HashMap::new());
    /// # }
    /// let cache = ThreadLocalCache::new(&CACHE);
    /// cache.insert("key", 100);
    /// assert_eq!(cache.get("key"), Some(100));
    /// assert_eq!(cache.get("missing"), None);
    /// ```
    pub fn get(&'static self, key: &str) -> Option<R> {
        let val = self.cache.with(|c| c.borrow().get(key).cloned());
        if val.is_some() && self.policy == EvictionPolicy::LRU {
            self.order.with(|o| {
                let mut o = o.borrow_mut();
                if let Some(pos) = o.iter().position(|k| k == key) {
                    o.remove(pos);
                    o.push_back(key.to_string());
                }
            });
        }
        val
    }

    /// Inserts a value into the cache with the specified key.
    ///
    /// If a value already exists for this key, it will be replaced.
    ///
    /// # Arguments
    ///
    /// * `key` - The cache key
    /// * `value` - The value to store
    ///
    /// # Examples
    ///
    /// ```
    /// # use std::cell::RefCell;
    /// # use std::collections::HashMap;
    /// # use cachelito_core::ThreadLocalCache;
    /// # thread_local! {
    /// #     static CACHE: RefCell<HashMap<String, i32>> = RefCell::new(HashMap::new());
    /// # }
    /// let cache = ThreadLocalCache::new(&CACHE);
    /// cache.insert("first", 1);
    /// cache.insert("first", 2); // Replaces previous value
    /// assert_eq!(cache.get("first"), Some(2));
    /// ```
    pub fn insert(&'static self, key: String, value: R) {
        self.cache
            .with(|c| c.borrow_mut().insert(key.clone(), value));
        self.order.with(|o| {
            let mut order = o.borrow_mut();
            if let Some(pos) = order.iter().position(|k| *k == key) {
                order.remove(pos);
            }
            order.push_back(key.clone());

            if let Some(limit) = self.limit {
                if order.len() > limit {
                    let evict_key = match self.policy {
                        EvictionPolicy::FIFO | EvictionPolicy::LRU => order.pop_front(),
                    };
                    if let Some(k) = evict_key {
                        self.cache.with(|c| {
                            c.borrow_mut().remove(&k);
                        });
                    }
                }
            }
        });
    }
}

/// Specialized implementation for caching `Result<T, E>` return types.
///
/// This implementation provides a method to cache only successful (`Ok`) results,
/// which is useful for functions that may fail - you typically don't want to cache
/// errors, as retrying the operation might succeed later.
///
/// # Type Parameters
///
/// * `T` - The success type (inner type of `Ok`)
/// * `E` - The error type (inner type of `Err`)
///
/// # Examples
///
/// ```
/// # use std::cell::RefCell;
/// # use std::collections::HashMap;
/// # use cachelito_core::ThreadLocalCache;
/// # thread_local! {
/// #     static CACHE: RefCell<HashMap<String, Result<i32, String>>> = RefCell::new(HashMap::new());
/// # }
/// let cache = ThreadLocalCache::new(&CACHE);
///
/// // Only Ok values are cached
/// cache.insert_result("success", &Ok(42));
/// assert_eq!(cache.get("success"), Some(Ok(42)));
///
/// // Err values are NOT cached
/// cache.insert_result("failure", &Err("error".to_string()));
/// assert_eq!(cache.get("failure"), None);
/// ```
impl<T: Clone + Debug + 'static, E: Clone + Debug + 'static> ThreadLocalCache<Result<T, E>> {
    /// Inserts a `Result` into the cache, but only if it's an `Ok` value.
    ///
    /// This method is specifically designed for caching functions that return
    /// `Result<T, E>`. It intelligently ignores `Err` values, as errors typically
    /// should not be cached (the operation might succeed on retry).
    ///
    /// Internally, it delegates to [`insert()`] to ensure eviction policy (`FIFO` or `LRU`)
    /// and cache limits are respected.
    ///
    /// # Arguments
    ///
    /// * `key` - The cache key
    /// * `value` - The `Result` to potentially cache
    ///
    /// # Behavior
    ///
    /// * If `value` is `Ok(v)`, stores `Ok(v.clone())` in the cache (with full eviction logic)
    /// * If `value` is `Err(_)`, does nothing (error is not cached)
    pub fn insert_result(&'static self, key: &str, value: &Result<T, E>) {
        if let Ok(val) = value {
            self.insert(key.to_string(), Ok(val.clone()));
        }
    }
}
