//! # Cachelito Core
//!
//! Core traits and utilities for the Cachelito caching library.
//!
//! This module provides the fundamental building blocks for cache key generation
//! and thread-local cache management.

use std::{cell::RefCell, collections::HashMap, fmt::Debug, thread::LocalKey};

/// Trait defining how to generate a cache key for a given type.
///
/// This trait must be implemented for any type that will be used as a function
/// parameter in a cached function. The cache key is used to uniquely identify
/// cached results.
///
/// # Examples
///
/// ```
/// use cachelito_core::CacheableKey;
///
/// #[derive(Debug)]
/// struct UserId(u64);
///
/// impl CacheableKey for UserId {
///     fn to_cache_key(&self) -> String {
///         format!("user_{}", self.0)
///     }
/// }
/// ```
pub trait CacheableKey {
    /// Converts this value into a string that can be used as a cache key.
    ///
    /// The returned string should uniquely identify the value to ensure
    /// correct cache behavior.
    fn to_cache_key(&self) -> String;
}

/// Marker trait for types that want to use the *default* cache key behavior.
///
/// Implement this trait for any type that should automatically get a cache key
/// derived from its `Debug` representation. This is the simplest way to make
/// a type cacheable.
///
/// # Examples
///
/// ```
/// use cachelito_core::DefaultCacheableKey;
///
/// #[derive(Debug, Clone)]
/// struct Product {
///     id: u32,
///     name: String,
/// }
///
/// // Enable default cache key generation based on Debug
/// impl DefaultCacheableKey for Product {}
/// ```
///
/// # Note
///
/// Types implementing this trait must also implement `Debug`, as the default
/// cache key is generated using `format!("{:?}", value)`.
pub trait DefaultCacheableKey: Debug {}

/// Blanket implementation for any type that explicitly opts in via `DefaultCacheableKey`.
///
/// This automatically implements `CacheableKey::to_cache_key()` for any type that
/// implements `DefaultCacheableKey`, using the type's `Debug` representation as the key.
///
/// # Performance Note
///
/// The cache key is generated by formatting the value with `{:?}`. For complex types,
/// consider implementing `CacheableKey` directly for better performance.
impl<T> CacheableKey for T
where
    T: DefaultCacheableKey + ?Sized,
{
    fn to_cache_key(&self) -> String {
        format!("{:?}", self)
    }
}

// ============================================================================
// Standard Library Type Implementations
// ============================================================================
// These implementations allow all common Rust types to be used as cache keys
// without requiring manual implementation.

// Unsigned integer types
impl DefaultCacheableKey for u8 {}
impl DefaultCacheableKey for u16 {}
impl DefaultCacheableKey for u32 {}
impl DefaultCacheableKey for u64 {}
impl DefaultCacheableKey for u128 {}
impl DefaultCacheableKey for usize {}

// Signed integer types
impl DefaultCacheableKey for i8 {}
impl DefaultCacheableKey for i16 {}
impl DefaultCacheableKey for i32 {}
impl DefaultCacheableKey for i64 {}
impl DefaultCacheableKey for i128 {}
impl DefaultCacheableKey for isize {}

// Floating point types
impl DefaultCacheableKey for f32 {}
impl DefaultCacheableKey for f64 {}

// Boolean type
impl DefaultCacheableKey for bool {}

// Character type
impl DefaultCacheableKey for char {}

// String types
impl DefaultCacheableKey for String {}
impl DefaultCacheableKey for &str {}

// Tuple types (up to 5 elements)
impl<T1: DefaultCacheableKey> DefaultCacheableKey for (T1,) {}
impl<T1: DefaultCacheableKey, T2: DefaultCacheableKey> DefaultCacheableKey for (T1, T2) {}
impl<T1: DefaultCacheableKey, T2: DefaultCacheableKey, T3: DefaultCacheableKey> DefaultCacheableKey
    for (T1, T2, T3)
{
}
impl<
        T1: DefaultCacheableKey,
        T2: DefaultCacheableKey,
        T3: DefaultCacheableKey,
        T4: DefaultCacheableKey,
    > DefaultCacheableKey for (T1, T2, T3, T4)
{
}
impl<
        T1: DefaultCacheableKey,
        T2: DefaultCacheableKey,
        T3: DefaultCacheableKey,
        T4: DefaultCacheableKey,
        T5: DefaultCacheableKey,
    > DefaultCacheableKey for (T1, T2, T3, T4, T5)
{
}

// Option and Result wrapper types
impl<T: DefaultCacheableKey> DefaultCacheableKey for Option<T> {}
impl<T: DefaultCacheableKey, E: DefaultCacheableKey> DefaultCacheableKey for Result<T, E> {}

// Collection types
impl<T: DefaultCacheableKey> DefaultCacheableKey for Vec<T> {}
impl<T: DefaultCacheableKey> DefaultCacheableKey for &[T] {}

/// Core cache abstraction that stores values in a thread-local HashMap.
///
/// This cache is designed to work with static thread-local maps declared using
/// the `thread_local!` macro. Each thread maintains its own independent cache,
/// ensuring thread safety without the need for locks.
///
/// # Type Parameters
///
/// * `R` - The type of values stored in the cache. Must be `'static` to satisfy
///   thread-local storage requirements.
///
/// # Thread Safety
///
/// The cache is thread-safe by design - each thread has its own independent copy
/// of the cache data. This means:
/// - No locks or synchronization needed
/// - No contention between threads
/// - Cache entries are not shared across threads
///
/// # Examples
///
/// ```
/// use std::cell::RefCell;
/// use std::collections::HashMap;
/// use cachelito_core::ThreadLocalCache;
///
/// thread_local! {
///     static MY_CACHE: RefCell<HashMap<String, i32>> = RefCell::new(HashMap::new());
/// }
///
/// let cache = ThreadLocalCache::new(&MY_CACHE);
/// cache.insert("answer", 42);
/// assert_eq!(cache.get("answer"), Some(42));
/// ```
pub struct ThreadLocalCache<R: 'static> {
    /// Reference to the thread-local storage key for the cache HashMap
    pub cache: &'static LocalKey<RefCell<HashMap<String, R>>>,
}

impl<R: Clone + 'static> ThreadLocalCache<R> {
    /// Creates a new `ThreadLocalCache` wrapper around a thread-local storage key.
    ///
    /// # Arguments
    ///
    /// * `cache` - A static reference to a `LocalKey` that stores the cache HashMap
    ///
    /// # Examples
    ///
    /// ```
    /// use std::cell::RefCell;
    /// use std::collections::HashMap;
    /// use cachelito_core::ThreadLocalCache;
    ///
    /// thread_local! {
    ///     static CACHE: RefCell<HashMap<String, String>> = RefCell::new(HashMap::new());
    /// }
    ///
    /// let cache = ThreadLocalCache::new(&CACHE);
    /// ```
    pub fn new(cache: &'static LocalKey<RefCell<HashMap<String, R>>>) -> Self {
        ThreadLocalCache { cache }
    }

    /// Retrieves a value from the cache by key.
    ///
    /// # Arguments
    ///
    /// * `key` - The cache key to look up
    ///
    /// # Returns
    ///
    /// * `Some(value)` if the key exists in the cache
    /// * `None` if the key is not found
    ///
    /// # Examples
    ///
    /// ```
    /// # use std::cell::RefCell;
    /// # use std::collections::HashMap;
    /// # use cachelito_core::ThreadLocalCache;
    /// # thread_local! {
    /// #     static CACHE: RefCell<HashMap<String, i32>> = RefCell::new(HashMap::new());
    /// # }
    /// let cache = ThreadLocalCache::new(&CACHE);
    /// cache.insert("key", 100);
    /// assert_eq!(cache.get("key"), Some(100));
    /// assert_eq!(cache.get("missing"), None);
    /// ```
    pub fn get(&self, key: &str) -> Option<R> {
        self.cache.with(|c| c.borrow().get(key).cloned())
    }

    /// Inserts a value into the cache with the specified key.
    ///
    /// If a value already exists for this key, it will be replaced.
    ///
    /// # Arguments
    ///
    /// * `key` - The cache key
    /// * `value` - The value to store
    ///
    /// # Examples
    ///
    /// ```
    /// # use std::cell::RefCell;
    /// # use std::collections::HashMap;
    /// # use cachelito_core::ThreadLocalCache;
    /// # thread_local! {
    /// #     static CACHE: RefCell<HashMap<String, i32>> = RefCell::new(HashMap::new());
    /// # }
    /// let cache = ThreadLocalCache::new(&CACHE);
    /// cache.insert("first", 1);
    /// cache.insert("first", 2); // Replaces previous value
    /// assert_eq!(cache.get("first"), Some(2));
    /// ```
    pub fn insert(&self, key: &str, value: R) {
        self.cache.with(|c| {
            c.borrow_mut().insert(key.to_string(), value);
        });
    }
}

/// Specialized implementation for caching `Result<T, E>` return types.
///
/// This implementation provides a method to cache only successful (`Ok`) results,
/// which is useful for functions that may fail - you typically don't want to cache
/// errors, as retrying the operation might succeed later.
///
/// # Type Parameters
///
/// * `T` - The success type (inner type of `Ok`)
/// * `E` - The error type (inner type of `Err`)
///
/// # Examples
///
/// ```
/// # use std::cell::RefCell;
/// # use std::collections::HashMap;
/// # use cachelito_core::ThreadLocalCache;
/// # thread_local! {
/// #     static CACHE: RefCell<HashMap<String, Result<i32, String>>> = RefCell::new(HashMap::new());
/// # }
/// let cache = ThreadLocalCache::new(&CACHE);
///
/// // Only Ok values are cached
/// cache.insert_result("success", &Ok(42));
/// assert_eq!(cache.get("success"), Some(Ok(42)));
///
/// // Err values are NOT cached
/// cache.insert_result("failure", &Err("error".to_string()));
/// assert_eq!(cache.get("failure"), None);
/// ```
impl<T: Clone + Debug + 'static, E: Clone + Debug + 'static> ThreadLocalCache<Result<T, E>> {
    /// Inserts a `Result` into the cache, but only if it's an `Ok` value.
    ///
    /// This method is specifically designed for caching functions that return
    /// `Result<T, E>`. It intelligently ignores `Err` values, as errors typically
    /// should not be cached (the operation might succeed on retry).
    ///
    /// # Arguments
    ///
    /// * `key` - The cache key
    /// * `value` - The `Result` to potentially cache
    ///
    /// # Behavior
    ///
    /// * If `value` is `Ok(v)`, stores `Ok(v.clone())` in the cache
    /// * If `value` is `Err(_)`, does nothing (error is not cached)
    pub fn insert_result(&self, key: &str, value: &Result<T, E>) {
        if let Ok(val) = value {
            self.cache.with(|c| {
                c.borrow_mut().insert(key.to_string(), Ok(val.clone()));
            });
        }
    }
}
