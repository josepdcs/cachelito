# Macro Expansion in Rust

## How to view the code generated by a macro

There are several ways to view the code generated by a procedural macro in Rust:

### 1. Using `eprintln!` in the macro (during compilation)

In the macro code you can add:

```rust
eprintln!("expanded tokens:\n{}", expanded);
```

This will print the generated code during compilation to stderr.

### 2. Using `cargo expand`

Install the tool:

```bash
cargo install cargo-expand
```

Then run:

```bash
cargo expand --example main
```

This will show all the expanded code from the file.

### 3. Using `rustc` directly

```bash
rustc -Z unpretty=expanded examples/main.rs
```

## What does `format!("{:?}")` do?

`format!("{:?}")` is a formatting macro that uses the `Debug` trait:

- **`{:?}`**: Uses the implementation of the `std::fmt::Debug` trait to convert a value into a human-readable text
  representation for debugging
- **`format!`**: Returns a `String` with the formatted value

### Example:

```rust
let tuple = (5, "hello", true);
let s = format!("{:?}", tuple);
// s = "(5, \"hello\", true)"
```

### In the `#[cache]` macro:

The macro uses `format!("{:?}")` to generate unique cache keys based on function arguments:

```rust
// For a function: fn sum(a: i32, b: i32)
let __key = format!("{:?}", (a, b));
// Generates keys like: "(10, 20)", "(5, 3)", etc.

// For a method: fn add(&self, a: i32, b: i32)
let __key = format!("{:?}", (&self, a, b));
// Generates keys like: "(Calculator, 5, 3)"
```

This allows each unique combination of arguments to have its own entry in the cache.

## Example of expanded code

For the function:

```rust
#[cache]
fn sum(a: i32, b: i32) -> i32 {
    println!("⏳ Executing (a + b)");
    a + b
}
```

It expands to something similar to:

```rust
fn sum(a: i32, b: i32) -> i32 {
    thread_local! {
        static _CACHE_SUM_MAP: std::cell::RefCell<std::collections::HashMap<String, i32>> 
            = std::cell::RefCell::new(std::collections::HashMap::new());
    }

    let __key = format!("{:?}", (a, b));

    let cached_result = _CACHE_SUM_MAP.with(|cache| {
        cache.borrow().get(&__key).cloned()
    });

    if let Some(cached) = cached_result {
        return cached;
    }

    let __result = (|| {
        println!("⏳ Executing (a + b)");
        a + b
    })();

    _CACHE_SUM_MAP.with(|cache| {
        cache.borrow_mut().insert(__key, __result.clone());
    });

    __result
}
```

## Changes made to support methods

The original problem was that a global `static` was being used, which is not allowed inside `impl` blocks:

**Before (doesn't work in methods):**

```rust
static CACHE: Lazy<Mutex<HashMap<...>>> = ...;
```

**After (works in both functions and methods):**

```rust
thread_local! {
    static CACHE: RefCell<HashMap<...>> = ...;
}
```

`thread_local!` allows defining per-thread static variables that can exist inside any function or method.

